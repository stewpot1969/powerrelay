
AVRA   Ver. 1.3.0 main.asm Sun Oct  9 22:29:31 2016


         
         ;  file to control a relay
         
          .list
         
         ; VOLTAGE LEVELS
         ; ADC result = 50.8*voltage - 2.39
          .define   V_HIGH            668     ; ~13.2V
          .define   V_LOW             617     ; ~12.2V
         
         ; temp reg for things
          .def  scratch = r23
         ; timer countdown for state changes etc
          .def  count   = r24
          .define   COUNT_PRE_ON      5   ; seconds of engine-on volts before bootup
          .define   COUNT_PRE_OFF     5    ; seconds from shutdown relay on to power off
          .define   COUNT_PRE_SHUT    10     ; secs of engine-off volts before shutdown
         
         ; prescaler for second counter
          .def  count2  = r25
          .define   COUNT2_PRESCALE   4
         
         ; state of the switch
          .def  state   = r26
          .define   STATE_IDLE        1   ; resting state
          .define   STATE_PRE_ON      2   ; engine started
          .define   STATE_ON          4   ; power on to Pi
          .define   STATE_PRE_SHUT    8   ; engine turned off, Pi still running
          .define   STATE_PRE_OFF     16  ; shutdown relay on, Pi shutting down
          .define   STATE_MANUAL      32  ; button has been pressed
         
         ; state of the voltage input
          .def  v_state = r27
          .define   V_STATE_SICK      1     ; <12.2V - battery getting down
          .define   V_STATE_OK        2     ; 12.2-13.2V  - engine off, battery OK
          .define   V_STATE_HIGH      3     ; >13.2V - engine running
         
         
          .macro    set_output
              in    r16,DDR@0
              ori   r16,1<<@1
              out   DDR@0,r16
          .endm
          .macro    set_pullup
              in    r16,PORT@0
              ori   r16,1<<@1
              out   PORT@0,r16
          .endm
          .macro    set_high
              in    r16,PORT@0
              ori   r16,1<<@1
              out   PORT@0,r16
          .endm
          .macro    set_low
              in    r16,PORT@0
              andi  r16,255-(1<<@1)
              out   PORT@0,r16
          .endm
         
          .dseg
          .org  SRAM_START
         
         ; myval:    .byte 1
         
          .cseg
          .org          0x0000
         
         
          reset:
C:000000 e90f          ldi     r16,low(RAMEND)
C:000001 bf0d          out     SPL,r16
         
             ; setup I/O
             ; 1: _reset
             ; 2: PB3 - relay out
             ; 3: PB4 - 2nd relay?
             ; 4: GND
             ; 5: PB0 - button
             ; 6: PB1 - indicator LED
             ; 7: PB2 - ADC1 - sys V in
             ; 8: 5V
C:000002   +      set_output  B,1       ; PB1 LED out
C:000002 b307      in    r16,DDRB
C:000003 6002      ori   r16,1<<1
C:000004 bb07      out   DDRB,r16
C:000005   +      set_output  B,3       ; PB3 relay 1 out
C:000005 b307      in    r16,DDRB
C:000006 6008      ori   r16,1<<3
C:000007 bb07      out   DDRB,r16
C:000008   +      set_output  B,4       ; PB4 relay 2 out
C:000008 b307      in    r16,DDRB
C:000009 6100      ori   r16,1<<4
C:00000a bb07      out   DDRB,r16
C:00000b   +      set_pullup  B,0       ; PB0 button pullup
C:00000b b308      in    r16,PORTB
C:00000c 6001      ori   r16,1<<0
C:00000d bb08      out   PORTB,r16
         
             ; setup ADC (Vref=Vcc, /8 prescaler (125kHz))
             ; PB2 (ADC1), ADLAR=0
             
C:00000e e001          ldi     r16,1     ; Vref=Vcc, ADLAR=0, MUX1=1 (ADC1 PB2)
C:00000f b907          out     ADMUX,r16
             
C:000010 e803          ldi     r16,(1<<ADEN)+3 ; enable ADC, /8
C:000011 b906          out     ADCSRA,r16
             
             ; setup timer0
             ; compare output modes normal, WGM=CTC
C:000012 e002          ldi     r16,0b00000010
C:000013 bd0f          out     TCCR0A,r16
             ; WGM=CTC, clock prescaler = 1024
C:000014 e005          ldi     r16,0b00000101
C:000015 bf03          out     TCCR0B,r16
             ; overflow every 250 cycles = 0.5 seconds
C:000016 ef0a          ldi     r16,250
C:000017 bf06          out     OCR0A,r16
         
             ; prepare states and stuff for the loop
C:000018 ef8f          ldi     count,-1        ; timer off
C:000019 e0a1          ldi     state,STATE_IDLE    ; state=IDLE
C:00001a e094          ldi     count2,COUNT2_PRESCALE  ; load prescaler
         
          loop:
             ; step 1: wait for the interrupt flag to be set
C:00001b b708          in    r16,TIFR0
C:00001c ff02          sbrs  r16,OCF0A
C:00001d cffd          rjmp  loop
             
             ; step 2: clear interrupt flag
C:00001e e004          ldi   r16,1<<OCF0A
C:00001f bf08          out   TIFR0,r16
         
             ; step 3 - read ADC
C:000020 ec01          ldi     r16,(1<<ADEN)+(1<<ADSC)+1   ; start conversion
C:000021 b906          out     ADCSRA,r16
          wfadc:
C:000022 b106          in      r16,ADCSRA
C:000023 7100          andi    r16,(1<<ADIF)     ; check if ADIF is set (ADC complete)
C:000024 f3e9          breq    wfadc
         
             ; step 4 - look at the voltage
C:000025 b104          in      r16,ADCL
C:000026 b115          in      r17,ADCH
C:000027 e92c          ldi     r18,low(V_HIGH)
C:000028 e032          ldi     r19,high(V_HIGH)
C:000029 1702          cp      r16,r18     ; subtract V_HIGH from ADC
C:00002a 0713          cpc     r17,r19
C:00002b f010          brcs    s4_1    ; branch if ADC < V_HIGH
C:00002c e0b3          ldi     v_state,V_STATE_HIGH
C:00002d c008          rjmp    s5
          s4_1:
C:00002e e629          ldi     r18,low(V_LOW)
C:00002f e032          ldi     r19,high(V_LOW)
C:000030 1702          cp      r16,r18   ; subtract V_LOW from ADC
C:000031 0713          cpc     r17,r19
C:000032 f010          brcs    s4_2      ; branch if ADC < V_LOW
C:000033 e0b2          ldi     v_state,V_STATE_OK
C:000034 c001          rjmp    s5
          s4_2:
C:000035 e0b1          ldi     v_state,V_STATE_SICK
             
             ; step 5  - decrement timer prescaler and timer
          s5:
C:000036 959a          dec   count2
C:000037 f719          brne  loop      ; no prescale zero? All done for this time
C:000038 e094          ldi   count2,COUNT2_PRESCALE    ; reload prescaler
C:000039 3f8f          cpi   count,-1      ; count=-1 means counter not being used
C:00003a f009          breq  s6
C:00003b 958a          dec   count
         
         
             ; step 6 - split out based on state
          s6:
C:00003c ede4          ldi   ZL,low(calltable*2)
C:00003d e0f0          ldi   ZH,high(calltable*2)
C:00003e 9105          lpm   r16,Z+
C:00003f 2300          tst   r16
C:000040 f2d1          breq  loop      ; table ends in zero
C:000041 9115          lpm   r17,Z+
C:000042 91c5          lpm   YL,Z+
C:000043 91d5          lpm   YH,Z+
             
         
          idleoff:    ; go into idle mode
C:000044 e0a1        ldi   state,STATE_IDLE
C:000045 ef8f        ldi   count,-1
C:000046 b308        in    r16,PORTB
C:000047 7e05        andi  r16,0b11100101  ; 1,3,4 off = power,shutdown,LED
C:000048 bb08        out   PORTB,r16
C:000049 9508        ret  
           
          preshut:    ; sets state=PRE_SHUT
C:00004a e0a8        ldi   state,STATE_PRE_SHUT
C:00004b e08a        ldi   count,COUNT_PRE_SHUT
C:00004c 9508        ret
           
          preoff:   ;state=PRE_SHUT,Vok
C:00004d 2388        tst   count     ; timer before setting shutdown relay
C:00004e f429        brne  preoff_2
C:00004f e1a0        ldi   state,STATE_PRE_OFF
C:000050 e085        ldi   count,COUNT_PRE_OFF
C:000051   +    set_high  B,3   ; shutdown relay on
C:000051 b308      in    r16,PORTB
C:000052 6008      ori   r16,1<<3
C:000053 bb08      out   PORTB,r16
          preoff_2:
C:000054 9508        ret
         
          timer_idle:     ; state=PRE_OFF,Vok
C:000055 2388        tst   count     ; wait for timer to run out before going idle
C:000056 f409        brne  timer_idle_2
C:000057 dfec        rcall idleoff
          timer_idle_2:
C:000058 9508        ret
         
          preon:      ; state=IDLE, Vhigh
C:000059 e0a2        ldi   state,STATE_PRE_ON
C:00005a e085        ldi   count,COUNT_PRE_ON
C:00005b 9508        ret
           
          pi_on:    ; turn the Pi on
C:00005c 2388        tst   count   ; do nothing until timer runs out
C:00005d f441        brne  pi_on_2
C:00005e e0a4        ldi   state,STATE_ON
C:00005f ef8f        ldi   count,-1
C:000060   +    set_high  B,1   ; LED on
C:000060 b308      in    r16,PORTB
C:000061 6002      ori   r16,1<<1
C:000062 bb08      out   PORTB,r16
C:000063   +    set_high  B,4   ; Pi power on
C:000063 b308      in    r16,PORTB
C:000064 6100      ori   r16,1<<4
C:000065 bb08      out   PORTB,r16
          pi_on_2:
C:000066 9508        ret
         
          cancel_shut:    ; goes from state preshut to state on i.e. engine restarts
C:000067 e0a4        ldi   state,STATE_ON
C:000068 ef8f        ldi   count,-1
C:000069 9508        ret
         
         
          calltable:
            .db   V_STATE_SICK,STATE_PRE_ON|STATE_ON|STATE_PRE_SHUT|STATE_PRE_OFF
C:00006A 011E
              .dw idleoff
C:00006b 0044
            .db   V_STATE_OK,STATE_PRE_ON
C:00006C 0202
              .dw idleoff
C:00006d 0044
            .db   V_STATE_OK,STATE_ON
C:00006E 0204
              .dw preshut
C:00006f 004a
            .db   V_STATE_OK,STATE_PRE_SHUT
C:000070 0208
              .dw preoff    
C:000071 004d
            .db   V_STATE_OK,STATE_PRE_OFF
C:000072 0210
              .dw timer_idle    
C:000073 0055
            .db   V_STATE_HIGH,STATE_IDLE
C:000074 0301
              .dw preon
C:000075 0059
            .db   V_STATE_HIGH,STATE_PRE_ON
C:000076 0302
              .dw pi_on
C:000077 005c
            .db   V_STATE_HIGH,STATE_PRE_SHUT
C:000078 0308
              .dw cancel_shut
C:000079 0067
            .db   0,1
C:00007A 0001
            .db   "1234"
C:00007B 31323334
         ;################################################################
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         


Segment usage:
   Code      :       125 words (250 bytes)
   Data      :         0 bytes
   EEPROM    :         0 bytes

Assembly completed with no errors.
