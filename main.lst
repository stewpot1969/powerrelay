
AVRA   Ver. 1.3.0 main.asm Fri Oct  7 13:04:08 2016


         
         ;  file to control a relay
         
          .include "tn13def.inc"
         ;***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************
         ;***** Created: 2005-01-11 10:31 ******* Source: ATtiny13.xml ************
         ;*************************************************************************
         ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
         ;* 
         ;* Number            : AVR000
         ;* File Name         : "tn13def.inc"
         ;* Title             : Register/Bit Definitions for the ATtiny13
         ;* Date              : 2005-01-11
         ;* Version           : 2.14
         ;* Support E-mail    : avr@atmel.com
         ;* Target MCU        : ATtiny13
         ;* 
         ;* DESCRIPTION
         ;* When including this file in the assembly program file, all I/O register 
         ;* names and I/O register bit names appearing in the data book can be used.
         ;* In addition, the six registers forming the three data pointers X, Y and 
         ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
         ;* SRAM is also defined 
         ;* 
         ;* The Register names are represented by their hexadecimal address.
         ;* 
         ;* The Register Bit names are represented by their bit number (0-7).
         ;* 
         ;* Please observe the difference in using the bit names with instructions
         ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
         ;* (skip if bit in register set/cleared). The following example illustrates
         ;* this:
         ;* 
         ;* in    r16,PORTB             ;read PORTB latch
         ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
         ;* out   PORTB,r16             ;output to PORTB
         ;* 
         ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
         ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
         ;* rjmp  TOV0_is_set           ;jump if set
         ;* ...                         ;otherwise do something else
         ;*************************************************************************
         
          #ifndef _TN13DEF_INC_
          #define _TN13DEF_INC_
         
         
          #pragma partinc 0
         
         ; ***** SPECIFY DEVICE ***************************************************
          .device ATtiny13
          #pragma AVRPART ADMIN PART_NAME ATtiny13
          .equ	SIGNATURE_000	= 0x1e
          .equ	SIGNATURE_001	= 0x90
          .equ	SIGNATURE_002	= 0x07
         
          #pragma AVRPART CORE CORE_VERSION V2
          #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
         
         
         ; ***** I/O REGISTER DEFINITIONS *****************************************
         ; NOTE:
         ; Definitions marked "MEMORY MAPPED"are extended I/O ports
         ; and cannot be used with IN/OUT instructions
          .equ	SREG	= 0x3f
          .equ	SPL	= 0x3d
          .equ	GIMSK	= 0x3b
          .equ	GIFR	= 0x3a
          .equ	TIMSK0	= 0x39
          .equ	TIFR0	= 0x38
          .equ	SPMCSR	= 0x37
          .equ	OCR0A	= 0x36
          .equ	MCUCR	= 0x35
          .equ	MCUSR	= 0x34
          .equ	TCCR0B	= 0x33
          .equ	TCNT0	= 0x32
          .equ	OSCCAL	= 0x31
          .equ	TCCR0A	= 0x2f
          .equ	DWDR	= 0x2e
          .equ	OCR0B	= 0x29
          .equ	GTCCR	= 0x28
          .equ	CLKPR	= 0x26
          .equ	WDTCR	= 0x21
          .equ	EEAR	= 0x1e
          .equ	EEDR	= 0x1d
          .equ	EECR	= 0x1c
          .equ	PORTB	= 0x18
          .equ	DDRB	= 0x17
          .equ	PINB	= 0x16
          .equ	PCMSK	= 0x15
          .equ	DIDR0	= 0x14
          .equ	ACSR	= 0x08
          .equ	ADMUX	= 0x07
          .equ	ADCSRA	= 0x06
          .equ	ADCH	= 0x05
          .equ	ADCL	= 0x04
          .equ	ADCSRB	= 0x03
         
         
         ; ***** BIT DEFINITIONS **************************************************
         
         ; ***** AD_CONVERTER *****************
         ; ADMUX - The ADC multiplexer Selection Register
          .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
          .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
          .equ	ADLAR	= 5	; Left Adjust Result
          .equ	REFS0	= 6	; Reference Selection Bit 0
         
         ; ADCSRA - The ADC Control and Status register
          .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
          .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
          .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
          .equ	ADIE	= 3	; ADC Interrupt Enable
          .equ	ADIF	= 4	; ADC Interrupt Flag
          .equ	ADATE	= 5	; ADC Auto Trigger Enable
          .equ	ADSC	= 6	; ADC Start Conversion
          .equ	ADEN	= 7	; ADC Enable
         
         ; ADCH - ADC Data Register High Byte
          .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
          .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
          .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
          .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
          .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
          .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
          .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
          .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
         
         ; ADCL - ADC Data Register Low Byte
          .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
          .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
          .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
          .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
          .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
          .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
          .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
          .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
         
         ; ADCSRB - ADC Control and Status Register B
          .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
          .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
          .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
         
         ; DIDR0 - Digital Input Disable Register 0
          .equ	ADC1D	= 2	; ADC2 Digital input Disable
          .equ	ADC3D	= 3	; ADC3 Digital input Disable
          .equ	ADC2D	= 4	; ADC2 Digital input Disable
          .equ	ADC0D	= 5	; ADC0 Digital input Disable
         
         
         ; ***** ANALOG_COMPARATOR ************
         ; ADCSRB - ADC Control and Status Register B
          .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
         
         ; ACSR - Analog Comparator Control And Status Register
          .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
          .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
          .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
          .equ	ACI	= 4	; Analog Comparator Interrupt Flag
          .equ	ACO	= 5	; Analog Compare Output
          .equ	ACBG	= 6	; Analog Comparator Bandgap Select
          .equ	AINBG	= ACBG	; For compatibility
          .equ	ACD	= 7	; Analog Comparator Disable
         
         ; DIDR0 - 
          .equ	AIN0D	= 0	; AIN0 Digital Input Disable
          .equ	AIN1D	= 1	; AIN1 Digital Input Disable
         
         
         ; ***** EEPROM ***********************
         ; EEAR - EEPROM Read/Write Access
          .equ	EEARL	= EEAR	; For compatibility
          .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
          .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
          .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
          .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
          .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
          .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
         
         ; EEDR - EEPROM Data Register
          .equ	EEDR0	= 0	; EEPROM Data Register bit 0
          .equ	EEDR1	= 1	; EEPROM Data Register bit 1
          .equ	EEDR2	= 2	; EEPROM Data Register bit 2
          .equ	EEDR3	= 3	; EEPROM Data Register bit 3
          .equ	EEDR4	= 4	; EEPROM Data Register bit 4
          .equ	EEDR5	= 5	; EEPROM Data Register bit 5
          .equ	EEDR6	= 6	; EEPROM Data Register bit 6
          .equ	EEDR7	= 7	; EEPROM Data Register bit 7
         
         ; EECR - EEPROM Control Register
          .equ	EERE	= 0	; EEPROM Read Enable
          .equ	EEWE	= 1	; EEPROM Write Enable
          .equ	EEPE	= EEWE	; For compatibility
          .equ	EEMWE	= 2	; EEPROM Master Write Enable
          .equ	EEMPE	= EEMWE	; For compatibility
          .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
          .equ	EEPM0	= 4	; 
          .equ	EEPM1	= 5	; 
         
         
         ; ***** CPU **************************
         ; SREG - Status Register
          .equ	SREG_C	= 0	; Carry Flag
          .equ	SREG_Z	= 1	; Zero Flag
          .equ	SREG_N	= 2	; Negative Flag
          .equ	SREG_V	= 3	; Two's Complement Overflow Flag
          .equ	SREG_S	= 4	; Sign Bit
          .equ	SREG_H	= 5	; Half Carry Flag
          .equ	SREG_T	= 6	; Bit Copy Storage
          .equ	SREG_I	= 7	; Global Interrupt Enable
         
         ; SPL - Stack Pointer Low Byte
          .equ	SP0	= 0	; Stack Pointer Bit 0
          .equ	SP1	= 1	; Stack Pointer Bit 1
          .equ	SP2	= 2	; Stack Pointer Bit 2
          .equ	SP3	= 3	; Stack Pointer Bit 3
          .equ	SP4	= 4
          .equ	SP5	= 5	; Stack Pointer Bit 5
          .equ	SP6	= 6	; Stack Pointer Bit 6
          .equ	SP7	= 7	; Stack Pointer Bit 7
         
         ; MCUCR - MCU Control Register
          .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
          .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
          .equ	SM0	= 3	; Sleep Mode Select Bit 0
          .equ	SM1	= 4	; Sleep Mode Select Bit 1
          .equ	SE	= 5	; Sleep Enable
          .equ	PUD	= 6	; Pull-up Disable
         
         ; MCUSR - MCU Status register
          .equ	PORF	= 0	; Power-On Reset Flag
          .equ	EXTRF	= 1	; External Reset Flag
          .equ	BORF	= 2	; Brown-out Reset Flag
          .equ	WDRF	= 3	; Watchdog Reset Flag
         
         ; OSCCAL - Oscillator Calibration Register
          .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
          .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
          .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
          .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
          .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
          .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
          .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
         
         ; CLKPR - Clock Prescale Register
          .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
          .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
          .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
          .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
          .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
         
         ; DWDR - Debug Wire Data Register
          .equ	DWDR0	= 0	; Debug Wire Data Register Bit 0
          .equ	DWDR1	= 1	; Debug Wire Data Register Bit 1
          .equ	DWDR2	= 2	; Debug Wire Data Register Bit 2
          .equ	DWDR3	= 3	; Debug Wire Data Register Bit 3
          .equ	DWDR4	= 4	; Debug Wire Data Register Bit 4
          .equ	DWDR5	= 5	; Debug Wire Data Register Bit 5
          .equ	DWDR6	= 6	; Debug Wire Data Register Bit 6
          .equ	DWDR7	= 7	; Debug Wire Data Register Bit 7
         
         ; SPMCSR - Store Program Memory Control and Status Register
          .equ	SPMEN	= 0	; Store program Memory Enable
          .equ	PGERS	= 1	; Page Erase
          .equ	PGWRT	= 2	; Page Write
          .equ	RFLB	= 3	; Read Fuse and Lock Bits
          .equ	CTPB	= 4	; Clear Temporary Page Buffer
         
         
         ; ***** PORTB ************************
         ; PORTB - Data Register, Port B
          .equ	PORTB0	= 0	; 
          .equ	PB0	= 0	; For compatibility
          .equ	PORTB1	= 1	; 
          .equ	PB1	= 1	; For compatibility
          .equ	PORTB2	= 2	; 
          .equ	PB2	= 2	; For compatibility
          .equ	PORTB3	= 3	; 
          .equ	PB3	= 3	; For compatibility
          .equ	PORTB4	= 4	; 
          .equ	PB4	= 4	; For compatibility
          .equ	PORTB5	= 5	; 
          .equ	PB5	= 5	; For compatibility
         
         ; DDRB - Data Direction Register, Port B
          .equ	DDB0	= 0	; 
          .equ	DDB1	= 1	; 
          .equ	DDB2	= 2	; 
          .equ	DDB3	= 3	; 
          .equ	DDB4	= 4	; 
          .equ	DDB5	= 5	; 
         
         ; PINB - Input Pins, Port B
          .equ	PINB0	= 0	; 
          .equ	PINB1	= 1	; 
          .equ	PINB2	= 2	; 
          .equ	PINB3	= 3	; 
          .equ	PINB4	= 4	; 
          .equ	PINB5	= 5	; 
         
         
         ; ***** EXTERNAL_INTERRUPT ***********
         ; MCUCR - MCU Control Register
         ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
         ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
         
         ; GIMSK - General Interrupt Mask Register
          .equ	GICR	= GIMSK	; For compatibility
          .equ	PCIE	= 5	; Pin Change Interrupt Enable
          .equ	INT0	= 6	; External Interrupt Request 0 Enable
         
         ; GIFR - General Interrupt Flag register
          .equ	PCIF	= 5	; Pin Change Interrupt Flag
          .equ	INTF0	= 6	; External Interrupt Flag 0
         
         ; PCMSK - Pin Change Enable Mask
          .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
          .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
          .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
          .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
          .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
          .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
         
         
         ; ***** TIMER_COUNTER_0 **************
         ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
          .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
          .equ	OCIE0A	= 2	; Timer/Counter0 Output Compare Match A Interrupt Enable
          .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
         
         ; TIFR0 - Timer/Counter0 Interrupt Flag register
          .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
          .equ	OCF0A	= 2	; Timer/Counter0 Output Compare Flag 0A
          .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
         
         ; OCR0A - Timer/Counter0 Output Compare Register
          .equ	OCR0_0	= 0	; 
          .equ	OCR0_1	= 1	; 
          .equ	OCR0_2	= 2	; 
          .equ	OCR0_3	= 3	; 
          .equ	OCR0_4	= 4	; 
          .equ	OCR0_5	= 5	; 
          .equ	OCR0_6	= 6	; 
          .equ	OCR0_7	= 7	; 
         
         ; TCCR0A - Timer/Counter  Control Register A
          .equ	WGM00	= 0	; Waveform Generation Mode
          .equ	WGM01	= 1	; Waveform Generation Mode
          .equ	COM0B0	= 4	; Compare Match Output B Mode
          .equ	COM0B1	= 5	; Compare Match Output B Mode
          .equ	COM0A0	= 6	; Compare Match Output A Mode
          .equ	COM0A1	= 7	; Compare Match Output A Mode
         
         ; TCNT0 - Timer/Counter0
          .equ	TCNT0_0	= 0	; 
          .equ	TCNT0_1	= 1	; 
          .equ	TCNT0_2	= 2	; 
          .equ	TCNT0_3	= 3	; 
          .equ	TCNT0_4	= 4	; 
          .equ	TCNT0_5	= 5	; 
          .equ	TCNT0_6	= 6	; 
          .equ	TCNT0_7	= 7	; 
         
         ; TCCR0B - Timer/Counter Control Register B
          .equ	CS00	= 0	; Clock Select
          .equ	CS01	= 1	; Clock Select
          .equ	CS02	= 2	; Clock Select
          .equ	WGM02	= 3	; Waveform Generation Mode
          .equ	FOC0B	= 6	; Force Output Compare B
          .equ	FOC0A	= 7	; Force Output Compare A
         
         ; OCR0B - Timer/Counter0 Output Compare Register
         ;.equ	OCR0_0	= 0	; 
         ;.equ	OCR0_1	= 1	; 
         ;.equ	OCR0_2	= 2	; 
         ;.equ	OCR0_3	= 3	; 
         ;.equ	OCR0_4	= 4	; 
         ;.equ	OCR0_5	= 5	; 
         ;.equ	OCR0_6	= 6	; 
         ;.equ	OCR0_7	= 7	; 
         
         ; GTCCR - General Timer Conuter Register
          .equ	PSR10	= 0	; Prescaler Reset Timer/Counter0
          .equ	TSM	= 7	; Timer/Counter Synchronization Mode
         
         
         ; ***** WATCHDOG *********************
         ; WDTCR - Watchdog Timer Control Register
          .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
          .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
          .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
          .equ	WDE	= 3	; Watch Dog Enable
          .equ	WDCE	= 4	; Watchdog Change Enable
          .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
          .equ	WDTIE	= 6	; Watchdog Timeout Interrupt Enable
          .equ	WDTIF	= 7	; Watchdog Timeout Interrupt Flag
         
         
         
         ; ***** LOCKSBITS ********************************************************
          .equ	LB1	= 0	; Lockbit
          .equ	LB2	= 1	; Lockbit
         
         
         ; ***** FUSES ************************************************************
         ; LOW fuse bits
          .equ	CKSEL0	= 0	; Select Clock Source
          .equ	CKSEL1	= 1	; Select Clock Source
          .equ	SUT0	= 2	; Select start-up time
          .equ	SUT1	= 3	; Select start-up time
          .equ	CKDIV8	= 4	; Start up with system clock divided by 8
          .equ	WDTON	= 5	; Watch dog timer always on
          .equ	EESAVE	= 6	; Keep EEprom contents during chip erase
          .equ	SPIEN	= 7	; SPI programming enable
         
         ; HIGH fuse bits
          .equ	RSTDISBL	= 0	; Disable external reset
          .equ	BODLEVEL0	= 1	; Enable BOD and select level
          .equ	BODLEVEL1	= 2	; Enable BOD and select level
          .equ	DWEN	= 3	; DebugWire Enable
          .equ	SELFPRGEN	= 4	; Self Programming Enable
         
         
         
         ; ***** CPU REGISTER DEFINITIONS *****************************************
          .def	XH	= r27
          .def	XL	= r26
          .def	YH	= r29
          .def	YL	= r28
          .def	ZH	= r31
          .def	ZL	= r30
         
         
         
         ; ***** DATA MEMORY DECLARATIONS *****************************************
          .equ	FLASHEND	= 0x01ff	; Note: Word address
          .equ	IOEND	= 0x003f
          .equ	SRAM_START	= 0x0060
          .equ	SRAM_SIZE	= 64
          .equ	RAMEND	= 0x009f
          .equ	XRAMEND	= 0x0000
          .equ	E2END	= 0x003f
          .equ	EEPROMEND	= 0x003f
          .equ	EEADRBITS	= 6
          #pragma AVRPART MEMORY PROG_FLASH 1024
          #pragma AVRPART MEMORY EEPROM 64
          #pragma AVRPART MEMORY INT_SRAM SIZE 64
          #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
         
         
         
         ; ***** BOOTLOADER DECLARATIONS ******************************************
          .equ	PAGESIZE	= 16
         
         
         
         ; ***** INTERRUPT VECTORS ************************************************
          .equ	INT0addr	= 0x0001	; External Interrupt 0
          .equ	PCI0addr	= 0x0002	; External Interrupt Request 0
          .equ	OVF0addr	= 0x0003	; Timer/Counter0 Overflow
          .equ	ERDYaddr	= 0x0004	; EEPROM Ready
          .equ	ACIaddr	= 0x0005	; Analog Comparator
          .equ	OC0Aaddr	= 0x0006	; Timer/Counter Compare Match A
          .equ	OC0Baddr	= 0x0007	; Timer/Counter Compare Match B
          .equ	WDTaddr	= 0x0008	; Watchdog Time-out
          .equ	ADCCaddr	= 0x0009	; ADC Conversion Complete
         
          .equ	INT_VECTORS_SIZE	= 10	; size in words
         
          #endif  /* _TN13DEF_INC_ */
         
         ; ***** END OF FILE ******************************************************
          
         
          .def    myreg       = r20
         
          .macro    set_output
              in    r16,DDR@0
              ori   r16,1<<@1
              out   DDR@0,r16
          .endm
          .macro    set_pullup
              in    r16,PORT@0
              ori   r16,1<<@1
              out   PORT@0,r16
          .endm
          .macro    set_high
              in    r16,PORT@0
              ori   r16,1<<@1
              out   PORT@0,r16
          .endm
          .macro    set_low
              in    r16,PORT@0
              andi  r16,255-(1<<@1)
              out   PORT@0,r16
          .endm
         
          .dseg
          .org  SRAM_START
         
         ; myval:    .byte 1
         
          .cseg
          .org          0x0000
         
         
          reset:
C:000000 e90f          ldi     r16,low(RAMEND)
C:000001 bf0d          out     SPL,r16
         
             ; setup I/O
             ; 1: _reset
             ; 2: PB3 - relay out
             ; 3: PB4 - 2nd relay?
             ; 4: GND
             ; 5: PB0 - button
             ; 6: PB1 - indicator LED
             ; 7: PB2 - ADC1 - sys V in
             ; 8: 5V
C:000002   +      set_output  B,1       ; PB1 LED out
C:000002 b307      in    r16,DDRB
C:000003 6002      ori   r16,1<<1
C:000004 bb07      out   DDRB,r16
C:000005   +      set_output  B,3       ; PB3 relay 1 out
C:000005 b307      in    r16,DDRB
C:000006 6008      ori   r16,1<<3
C:000007 bb07      out   DDRB,r16
C:000008   +      set_output  B,4       ; PB4 relay 2 out
C:000008 b307      in    r16,DDRB
C:000009 6100      ori   r16,1<<4
C:00000a bb07      out   DDRB,r16
C:00000b   +      set_pullup  B,0       ; PB0 button pullup
C:00000b b308      in    r16,PORTB
C:00000c 6001      ori   r16,1<<0
C:00000d bb08      out   PORTB,r16
         
             ; setup ADC (Vref=Vcc, /8 prescaler (125kHz))
             ; PB2 (ADC1), ADLAR=0
             
C:00000e e001          ldi     r16,1     ; Vref=Vcc, ADLAR=0, MUX1=1 (ADC1 PB2)
C:00000f b907          out     ADMUX,r16
             
C:000010 e803          ldi     r16,(1<<ADEN)+3 ; enable ADC, /8
C:000011 b906          out     ADCSRA,r16
             
             ; setup timer0
             ; compare output modes normal, WGM=CTC
C:000012 e002          ldi     r16,0b00000010
C:000013 bd0f          out     TCCR0A,r16
             ; WGM=CTC, clock prescaler = 1024
C:000014 e005          ldi     r16,0b00000101
C:000015 bf03          out     TCCR0B,r16
             ; overflow every 250 cycles = 0.5 seconds
C:000016 ef0a          ldi     r16,250
C:000017 bf06          out     OCR0A,r16
             ; enable Compare A interrupt
             ;ldi     r16,1<<OCIE0A
             ;out     TIMSK0,r16
             ; #### Don't enable any interrupts -
             ; poll the interrupt flag instead
         
         
          loop:
             ; step 1 - read ADC
C:000018 ec01          ldi     r16,(1<<ADEN)+(1<<ADSC)+1   ; start conversion
C:000019 b906          out     ADCSRA,r16
          wfadc:
C:00001a b106          in      r16,ADCSRA
C:00001b 7100          andi    r16,(1<<ADIF)     ; check if ADIF is set (ADC complete)
C:00001c f3e9          breq    wfadc
             ; flash first two bits
C:00001d b125          in      r18,ADCH
C:00001e 0f22          lsl     r18
C:00001f 0f22          lsl     r18
C:000020 0f22          lsl     r18
C:000021 0f22          lsl     r18
C:000022 0f22          lsl     r18
C:000023 0f22          lsl     r18
C:000024 d00d          rcall   flash1
C:000025 d00c          rcall   flash1
C:000026 b124          in      r18,ADCL
C:000027 d00a          rcall   flash1
C:000028 d009          rcall   flash1
C:000029 d008          rcall   flash1
C:00002a d007          rcall   flash1
C:00002b d006          rcall   flash1
C:00002c d005          rcall   flash1
C:00002d d004          rcall   flash1
C:00002e d003          rcall   flash1
C:00002f d015          rcall   wait_long    
C:000030 d014          rcall   wait_long    
C:000031 cfe6          rjmp    loop
         
          flash1:       ; short or long flash based on MSB of r18
C:000032   +      set_high  B,1
C:000032 b308      in    r16,PORTB
C:000033 6002      ori   r16,1<<1
C:000034 bb08      out   PORTB,r16
C:000035 d008          rcall   wait_short
C:000036 0f22          lsl     r18
C:000037 f408          brcc    flash12
C:000038 d00c          rcall   wait_long
          flash12:
C:000039   +      set_low   B,1
C:000039 b308      in    r16,PORTB
C:00003a 7f0d      andi  r16,255-(1<<1)
C:00003b bb08      out   PORTB,r16
C:00003c d008          rcall   wait_long
C:00003d 9508          ret
         
          wait_short:
C:00003e ef5a          ldi   r21,250     ; ~250 x 760 cycles ~ 0.2 sec
          wait_short_1:
C:00003f ef6f          ldi   r22,255
          wait_short_2:
C:000040 956a          dec   r22
C:000041 f7f1          brne  wait_short_2
C:000042 955a          dec   r21
C:000043 f7d9          brne  wait_short_1
C:000044 9508          ret
          wait_long:
C:000045 dff8          rcall wait_short
C:000046 dff7          rcall wait_short
C:000047 dff6          rcall wait_short
C:000048 dff5          rcall wait_short
C:000049 dff4          rcall wait_short
C:00004a dff3          rcall wait_short
C:00004b 9508          ret
         
         
         
             ; step 1: wait for the interrupt flag to be set
C:00004c b708          in    r16,TIFR0
C:00004d ff02          sbrs  r16,OCF0A
C:00004e cfc9          rjmp  loop
             
             ; step 2: clear interrupt flag
C:00004f e004          ldi   r16,1<<OCF0A
C:000050 bf08          out   TIFR0,r16
             
             ; step 3: invert LED
C:000051 b308          in    r16,PORTB
C:000052 e012          ldi   r17,0b00000010
C:000053 2701          eor   r16,r17
C:000054 bb08          out   PORTB,r16
             
            ; step 4: do it all again
C:000055 cfc2          rjmp  loop
             
          nowhere:
C:000056 cfff          rjmp    nowhere
         
         ;################################################################
         
             
          ext_int0:
          pc_int0:
          tim0_ovf:
          ee_rdy:
          ana_comp:
          tim0_compa:
          tim0_compb:
          watchdog:
          adc_complete:
         ;    reti


Segment usage:
   Code      :        87 words (174 bytes)
   Data      :         0 bytes
   EEPROM    :         0 bytes

Assembly completed with no errors.
